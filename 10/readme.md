# 十、编译器I

第十和第十一章的内容是完成编译器前端的开发，将高级语言代码编译为中间语言。如何将一种符号序列，按照一定的规则解析和翻译为另一种符号序列，是一个普遍的问题。

- 与之前的惯例一样，本书的每一章会先介绍通用的思想和理论，之后再结合具体的语言来实现。

- 从汇编器到后端编译器再到前端编译器，输入解析部分的复杂都增加了一个层次。

    汇编指令到机器码的翻译是一一对应的。

    后端编译器的输入是中间语言构成的逐行的代码序列，对输入的解析仍然相对简单，复杂的部分主要是在输出时需要将抽象的中间代码翻译为对应的汇编指令。

    前端编译器的输入是高级语言代码，输入中可能包含层级嵌套的语法结构。

    高级语言的抽象使得我们可以用形式化的语法规则来描述语言的结构，这也是编译原理课程的重点内容。

- 本章的目标是实现前端编译器中的解析部分，旨在将输入的高级语言代码转换为结构化的词法树。生成目标语言代码的部分留在下一章实现。

## 分析器

对代码的分析通常包含两个步骤构成：词法分析和语法分析。

### 词法分析

    词法分析将输入的代码分解为单词，这些单词是代码的基本元素，如关键字、标识符、常量等。

    词法分析通常由状态机或正则表达式来实现。

    正则表达式实际上也可以被转化为一个非确定有限自动机（Nondeterministic Finite Automata, NFA）。

    NFA意味着在某个状态输入某个符号时可以有多条状态转移路径。

    ![Everything is a statemachine](../images/Ch1001_regular.png)

    词法分析中需要引入的一个概念是最长匹配原则，即在多个匹配的情况下，选择最长的匹配。例如，对于`if`和`ifelse`两个关键字，如果输入的代码是`ifelse`，则应该匹配为一个`ifelse`关键字，而不是一个`if`关键字和一个`else`标识符。

### 语法分析

    语法分析将单词按照语法规则组织成结构化的树形结构，这个结构被称为词法树。

    语法分析通常由一种比正则表达式更复杂的文法：上下文无关文法（Context-Free Grammar, CFG）来描述。

#### 上下文无关文法

    上下文无关文法（Context Free Grammar, CFG）定义为一个四元组：`G = (N, T, P, S)`，其中`N`是非终结符集合，`T`是终结符集合，`P`是产生式规则集合，`S`是开始符号（$S\in N$且唯一）。

    产生式规则的形式是`A -> α`，其中`A`是一个非终结符，`α`是一个符号串，可以是终结符、非终结符或空串。

    例如，下面是一个简单的四则运算文法的产生式规则：

    ```text
    E -> E + E | E * E | (E) | -E | id
    ```

    推导即是将某个产生式的左边替换成它的右边。每一步推导需要选择替换哪个非终结符，以及使用哪个产生式。

    Jack是一种LL(1)语言，即从左到右分析，每次推导最左边的符号。这种语言的语法分析器可以使用递归下降法（recursive decent）来实现。

    上下文无关意味着产生式规则的左边（Head）只包含一个非终结符。如果存在多个非终结符，一个符号的推导可能依赖于其他符号，这种文法被称为上下文相关文法。

    递归下降法是一种自顶向下的解析方法，即从根节点开始，递归地向下解析每个子节点。每个非终结符对应一个解析函数，函数的返回值是一个树节点。

## 输出

- 书中选择使用XML来表示这种结构化的词法树。XML是一种通用的标记语言，与HTML类似，使用标签来描述文档的结构。XML的标签是成对出现的，有开始标签和结束标签，中间可以包含文本或其他标签。例如：

    ```xml
    <book>
        <title>The Elements of Computing Systems</title>
        <author>Noam Nisan and Shimon Schocken</author>
    </book>
    ```

## 实现

书中给出的解析器的参考设计同样分为三个部分：`Analyzer`、`Tokenizer`和`CompilationEngine`。

- `Analyzer`是解析器的入口，负责读取输入文件，调用`Tokenizer`来将输入的代码分解为单词，然后调用`CompilationEngine`来将单词转换为词法树。

- 建议的实现顺序是先实现`Tokenizer`，再实现不包括表达式和数组语句的`CompilationEngine`，最后再实现表达式和数组语句的解析。中间的每一步都有对应的测试用例。

    Tokenizer如果使用正则逃课则较为简单。

    注意注释的语法有三种：`//`、`/* */`和`/** */`。

- 由于Jack的词法分析是一个相对简单的映射过程，我们可以使用Python的正则表达式来实现`Tokenizer`。

## 测试

- 参考资料中给出了测试用的jack代码和对应的XML输出，可以用来验证编译器的正确性。

![alt text](../images/Ch1002_textComp.png)

## 补充

- 实际上，解析器的代码通常会由另一个程序来生成。开发者将语法规则输入到对应的工具中，并生成对应的解析器。这种工具被称为编译器生成器。常用的编译器生成器有ANTLR、Yacc等。

- 书中绕过的一个关键内容是编译中的错误检查。在实际的编译器中，我们需要对输入的代码进行各种检查，如类型检查、语法检查、语义检查等。这些检查通常会在解析的过程中进行。