# 十、编译器I

第十和第十一章的内容是完成编译器前端的开发，将高级语言代码编译为中间语言。如何将一种符号序列，按照一定的规则解析和翻译为另一种符号序列，是一个普遍的问题。

- 与之前的惯例一样，本书的每一章会先介绍通用的思想和理论，之后再结合具体的语言来实现。

- 从汇编器到后端编译器再到前端编译器，输入解析部分的复杂都增加了一个层次。

    汇编指令到机器码的翻译是一一对应的。

    后端编译器的输入是中间语言构成的逐行的代码序列，对输入的解析仍然相对简单，复杂的部分主要是在输出时需要将抽象的中间代码翻译为对应的汇编指令。

    前端编译器的输入是高级语言代码，输入中可能包含层级嵌套的语法结构。因此，我们需要专门的设计，来将其转换为结构化的符号。

- 本章的目标是实现前端编译器中的解析部分，旨在将输入的高级语言代码转换为结构化的词法树。生成目标语言代码的部分留在下一章实现。

## 分析器

对代码的分析通常包含两个步骤构成：词法分析和语法分析。

- 词法分析：将输入的代码分解为单词，这些单词是代码的基本元素，如关键字、标识符、常量等。

    词法分析通常由状态机或正则表达式来实现。

    正则表达式实际上也可以被转化为一个非确定有限自动机（Nondeterministic Finite Automata, NFA）。

    NFA意味着在某个状态输入某个符号时可以有多条状态转移路径。

![Everything is a statemachine](../images/Ch1001_regular.png)

- 语法分析：将单词按照语法规则组织成结构化的树形结构，这个结构被称为词法树。

    Jack是一种LL(1)语言，即从左到右扫描，从左到右规约，每次扫描一个符号，每次规约一个符号。这种语言的语法分析器可以使用递归下降法（recursive decent）来实现。

    递归下降法是一种自顶向下的解析方法，即从根节点开始，递归地向下解析每个子节点。每个非终结符对应一个解析函数，函数的返回值是一个树节点。

## 输出

- 书中选择使用XML来表示这种结构化的词法树。XML是一种通用的标记语言，与HTML类似，使用标签来描述文档的结构。XML的标签是成对出现的，有开始标签和结束标签，中间可以包含文本或其他标签。例如：

    ```xml
    <book>
        <title>The Elements of Computing Systems</title>
        <author>Noam Nisan and Shimon Schocken</author>
    </book>
    ```

## 实现

书中给出的解析器的参考设计同样分为三个部分：`Analyzer`、`Tokenizer`和`CompilationEngine`。

- `Analyzer`是解析器的入口，负责读取输入文件，调用`Tokenizer`来将输入的代码分解为单词，然后调用`CompilationEngine`来将单词转换为词法树。

- 建议的实现顺序是先实现`Tokenizer`，再实现不包括表达式和数组语句的`CompilationEngine`，最后再实现表达式和数组语句的解析。中间的每一步都有对应的测试用例。

    Tokenizer如果使用正则逃课则较为简单。

    注意注释的语法有三种：`//`、`/* */`和`/** */`。

- 由于Jack的词法分析是一个相对简单的映射过程，我们可以使用Python的正则表达式来实现`Tokenizer`。

## 测试

- 参考资料中给出了测试用的jack代码和对应的XML输出，可以用来验证编译器的正确性。

![alt text](../images/Ch1002_textComp.png)

## 补充

- 实际上，解析器的代码通常会由另一个程序来生成。开发者将语法规则输入到对应的工具中，并生成对应的解析器。这种工具被称为编译器生成器。常用的编译器生成器有ANTLR、Yacc等。

- 书中绕过的一个关键内容是编译中的错误检查。在实际的编译器中，我们需要对输入的代码进行各种检查，如类型检查、语法检查、语义检查等。这些检查通常会在解析的过程中进行。